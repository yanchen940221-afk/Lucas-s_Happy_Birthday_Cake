<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pixel Strawberry Cream Cake</title>
  <link rel="stylesheet" href="./style.css" />
</head>
<body>
  <main class="wrap">
    <h1 class="title">Strawberry Cream Cake</h1>

    <div class="card">
      <canvas id="view" aria-label="像素風草莓奶油三層生日蛋糕（24根蠟燭）"></canvas>
    </div>

    <p class="tip">想更像參考圖：把下面 JS 的 <b>STICKER_OUTLINE</b>、<b>PX</b>、<b>CANDLE_COUNT</b> 改一改就好。</p>
  </main>

<script>
(() => {
  // ===== 你最常改的三個地方 =====
  const PX = 6;                 // 像素放大倍率（越大越顆粒）
  const CANDLE_COUNT = 24;       // 蠟燭數量（你要 24）
  const STICKER_OUTLINE = {      // 貼紙外框厚度
    white: 3,                    // 白邊半徑
    shadow: 5                    // 淡灰外圈半徑
  };

  // 內部畫布尺寸（低解析度像素圖）
  const W = 160;
  const H = 120;

  const view = document.getElementById("view");
  view.width = W * PX;
  view.height = H * PX;

  const v = view.getContext("2d");
  v.imageSmoothingEnabled = false;

  // Offscreen: cake sprite
  const base = document.createElement("canvas");
  base.width = W; base.height = H;
  const b = base.getContext("2d");
  b.imageSmoothingEnabled = false;

  // --- Palette（偏向你那張圖的色感） ---
  const P = {
    outline: "#3a2026",
    outline2: "#5b2b35",
    sponge: "#f3c08a",
    sponge2: "#e9a86b",
    cream: "#fff8fb",
    cream2: "#ffd8e6",
    jam: "#d84a6a",
    jam2: "#b83b58",
    straw: "#ea3a57",
    straw2: "#b9243a",
    seed: "#ffd36a",
    leaf: "#3aa56a",
    leaf2: "#267b4c",
    candle: ["#ff8fb1", "#ffb36a", "#8ad7ff"], // 蠟燭身體變化
    flame1: "#ffd36a",
    flame2: "#ff8a4d",
  };

  // ===== Pixel helpers =====
  function px(x, y, c) {
    if (x < 0 || y < 0 || x >= W || y >= H) return;
    b.fillStyle = c;
    b.fillRect(x, y, 1, 1);
  }

  function fillEllipse(cx, cy, rx, ry, c) {
    const x0 = Math.floor(cx - rx), x1 = Math.ceil(cx + rx);
    const y0 = Math.floor(cy - ry), y1 = Math.ceil(cy + ry);
    const rx2 = rx * rx, ry2 = ry * ry;

    for (let y = y0; y <= y1; y++) {
      for (let x = x0; x <= x1; x++) {
        const dx = x - cx, dy = y - cy;
        if ((dx*dx)/rx2 + (dy*dy)/ry2 <= 1) px(x, y, c);
      }
    }
  }

  function blob(x, y, r, c) {
    // 小圓形像素奶油塊
    for (let yy = -r; yy <= r; yy++) {
      for (let xx = -r; xx <= r; xx++) {
        if (xx*xx + yy*yy <= r*r) px(x + xx, y + yy, c);
      }
    }
  }

  function drip(x, yTop, len, c) {
    for (let i = 0; i < len; i++) px(x, yTop + i, c);
  }

  function strawberryHalf(x, y) {
    // 參考圖那種「半顆草莓」的小像素
    const pts = [
      [0,2],[1,1],[2,1],[3,1],[4,2],
      [0,3],[1,2],[2,2],[3,2],[4,3],
      [1,3],[2,3],[3,3],
      [2,4],
    ];
    for (const [dx,dy] of pts) px(x+dx, y+dy, P.straw);
    // darker edge
    px(x+0,y+3,P.straw2); px(x+4,y+3,P.straw2); px(x+2,y+4,P.straw2);
    // seeds
    px(x+2,y+2,P.seed); px(x+1,y+3,P.seed); px(x+3,y+3,P.seed);
    // tiny leaf hint
    px(x+2,y+0,P.leaf); px(x+1,y+0,P.leaf2); px(x+3,y+0,P.leaf2);
  }

  function topStrawberry(x, y) {
    // 上面那圈比較大顆
    fillEllipse(x+3, y+4, 4.2, 3.6, P.straw);
    fillEllipse(x+3, y+5, 4.2, 3.6, P.straw2); // 下緣加深
    px(x+1,y+3,P.seed); px(x+3,y+4,P.seed); px(x+5,y+5,P.seed);
    // leaf
    px(x+3,y+0,P.leaf); px(x+2,y+1,P.leaf2); px(x+4,y+1,P.leaf2);
  }

  // ===== Cake drawing =====
  function drawTier(cx, cy, rx, ry) {
    // outline base (bigger)
    fillEllipse(cx, cy, rx+1, ry+1, P.outline);

    // sponge body (slightly lower)
    fillEllipse(cx, cy+2, rx, ry, P.sponge);
    fillEllipse(cx, cy+3, rx, ry, P.sponge2); // bottom shading

    // top cream (slightly upper)
    fillEllipse(cx, cy-3, rx-2, ry-3, P.cream);
    fillEllipse(cx, cy-2, rx-2, ry-3, P.cream2); // subtle shading

    // edge cream blobs
    for (let i = -rx+6; i <= rx-6; i += 8) {
      const yy = Math.floor(cy + ry - 2 - Math.abs(i) * 0.02);
      blob(cx + i, yy, 2, P.cream);
      blob(cx + i + 1, yy + 1, 2, P.cream2);
    }

    // front drips (like reference)
    drip(cx, cy+2, 6, P.cream);
    drip(cx+6, cy+1, 4, P.cream);
    drip(cx-6, cy+1, 4, P.cream2);

    // inner outline accent
    // (draw a thinner ring by drawing a slightly smaller outline2 on top edge area)
    fillEllipse(cx, cy+1, rx-2, ry-1, P.outline2);
    fillEllipse(cx, cy+2, rx-3, ry-2, P.sponge);
  }

  function drawFillingStrawberries(y, startX, count, step) {
    for (let i = 0; i < count; i++) strawberryHalf(startX + i*step, y);
  }

  function drawCandles() {
    // 2 rows x 12 = 24 candles
    const cols = 12;
    const rows = Math.ceil(CANDLE_COUNT / cols);

    const topY = 20;        // 蠟燭底座高度（調這個會整排上下移）
    const startX = 42;      // 左邊起點（調這個會左右移）
    const gapX = 6;         // 每根蠟燭間距
    const rowGap = 7;

    for (let i = 0; i < CANDLE_COUNT; i++) {
      const r = Math.floor(i / cols);
      const c = i % cols;

      const x = startX + c * gapX;
      const y = topY + r * rowGap;

      const body = P.candle[i % P.candle.length];

      // flame (pixel)
      px(x+1, y-7, P.flame1);
      px(x+1, y-6, P.flame2);
      px(x,   y-6, P.flame1);
      px(x+2, y-6, P.flame1);
      px(x+1, y-5, P.flame1);

      // wick
      px(x+1, y-4, P.outline);

      // candle body (3px wide)
      for (let yy = 0; yy < 8; yy++) {
        px(x,   y+yy, body);
        px(x+1, y+yy, body);
        px(x+2, y+yy, body);
        // highlight
        if (yy % 2 === 0) px(x, y+yy, "#ffd6e4");
      }

      // small "wax drip" / base (yellow-ish like reference)
      px(x+1, y+8, P.seed);
      px(x,   y+8, P.flame2);
      px(x+2, y+8, P.flame2);
      px(x+1, y+9, P.flame2);
    }
  }

  function drawCake() {
    b.clearRect(0,0,W,H);

    // --- 3 tiers (positions tuned to resemble your reference) ---
    drawTier(80, 86, 62, 18);  // bottom
    drawTier(80, 62, 54, 16);  // middle
    drawTier(80, 40, 46, 14);  // top

    // --- strawberry fillings between tiers ---
    drawFillingStrawberries(74, 34, 10, 10);
    drawFillingStrawberries(52, 38, 9,  10);

    // --- top strawberry ring behind candles ---
    for (let i = 0; i < 7; i++) topStrawberry(44 + i*12, 10);

    // --- candles on top ---
    drawCandles();
  }

  // ===== Sticker outline (white border + soft outer) =====
  function tintCanvas(src, color) {
    const t = document.createElement("canvas");
    t.width = W; t.height = H;
    const tx = t.getContext("2d");
    tx.imageSmoothingEnabled = false;

    tx.clearRect(0,0,W,H);
    tx.drawImage(src, 0, 0);

    tx.globalCompositeOperation = "source-in";
    tx.fillStyle = color;
    tx.fillRect(0,0,W,H);

    tx.globalCompositeOperation = "source-over";
    return t;
  }

  function makeSticker(src) {
    const out = document.createElement("canvas");
    out.width = W; out.height = H;
    const o = out.getContext("2d");
    o.imageSmoothingEnabled = false;

    const white = tintCanvas(src, "#ffffff");
    const soft  = tintCanvas(src, "rgba(110,70,80,0.25)");

    // outer soft ring
    const R2 = STICKER_OUTLINE.shadow;
    for (let dy = -R2; dy <= R2; dy++) {
      for (let dx = -R2; dx <= R2; dx++) {
        if (dx*dx + dy*dy <= R2*R2) o.drawImage(soft, dx, dy);
      }
    }

    // white border
    const R1 = STICKER_OUTLINE.white;
    for (let dy = -R1; dy <= R1; dy++) {
      for (let dx = -R1; dx <= R1; dx++) {
        if (dx*dx + dy*dy <= R1*R1) o.drawImage(white, dx, dy);
      }
    }

    // original sprite on top
    o.drawImage(src, 0, 0);
    return out;
  }

  // ===== Render =====
  function render() {
    drawCake();
    const sticker = makeSticker(base);

    v.clearRect(0,0,view.width,view.height);
    v.imageSmoothingEnabled = false;
    v.drawImage(sticker, 0, 0, W*PX, H*PX);
  }

  render();
})();
</script>
</body>
</html>

